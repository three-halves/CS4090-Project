@page "/event/{ID:guid}"
@implements IDisposable
@using Db
@using System
@using Microsoft.EntityFrameworkCore
@using System.Globalization
@inject IDbContextFactory<DatabaseContext> DbFactory
@inject NavigationManager NavigationManager
@rendermode InteractiveServer
@inject AuthenticationStateProvider AuthenticationStateProvider

<h1>@(event_?.Title)</h1>
<p>@(event_?.Description)</p>
<p>@ID</p>

<style>
.calendar-grid {
    width:  clamp(100px, 50%, 600px);
    height: 40rem;

    display: grid;
    grid-template-rows: repeat(48, 1fr);
    grid-template-columns: repeat(@(_totalCells/48), 1fr);
    column-gap: 0.1rem;
}
.calendar-toolbar {
    display: flex;
    width: 50%;
}
</style>

<AuthorizeView Context="Account"> 
    <Authorized>
        <div class="calendar-grid" @onmousedown="SetMouseDown" @onmouseup="SetMouseUp" draggable="false">
            @for (int i = 0; i < _totalCells; i++)
            {
                int _i = i;
                <UI.CalendarCell
                @ref="AddToSelectors"
                OnMouseEnter="() => MouseEnterTimeStep(_i)" 
                MaxAttendeeCount=@event_!.Attendees.Count() 
                AttendeeCount=@_calendarCellAttendeeCounts[_i] />
            }
        </div>

        <div class="calendar-toolbar">
        <button @onclick="SubmitAvailability">Submit Availability</button>
        <button @onclick="ResetCalendar">Reset Calendar</button>
        <button @onclick="DeleteUserAvailability">Delete My Availability</button>
        </div>
    </Authorized>
    <NotAuthorized>
        Login to submit availability for this event.
    </NotAuthorized>
</AuthorizeView>


@code {
    [Parameter]
    public Guid ID { get; set; }

    private Db.Event? event_;
    private Db.User? user_;
    private DatabaseContext? context;

    private List<int> _calendarCellAttendeeCounts = new();

    // How many cells/time slots the calendar needs to render
    private int _totalCells;

    private List<UI.CalendarCell> _calendarCells = new();
    private UI.CalendarCell AddToSelectors {
        set 
        {
            if (_calendarCells.Count() >= _totalCells) return;
            _calendarCells.Add(value); 
        }
    }

    // Mouse down state used for dragging input
    private bool _mouseDown;

    private void SetMouseDown()
    {
        _mouseDown = true;
    }

    private void SetMouseUp()
    {
        _mouseDown = false;
    }

    private void MouseEnterTimeStep(int index)
    {
        if(_mouseDown) _calendarCells[index].ToggleAvailability();
    }

    protected override async Task OnInitializedAsync()
    {
        context = await DbFactory.CreateDbContextAsync();
        event_ = await context.Events.FindAsync(ID);
        List<Db.Event> events = await context.Events.ToListAsync();
        if (event_ == null)
        {
            NavigationManager.NavigateTo("/not-found", true);
        }

        AuthenticationState? authState = await AuthenticationStateProvider.GetAuthenticationStateAsync();
        if (context != null && authState?.User.Identity?.Name != null)
            user_ = await context.Users.FindAsync(new Guid(authState.User.Identity.Name));

        if (event_ != null && context != null)
        {
            _totalCells = 48 * (int)((event_.LastPossibleDate - event_.FirstPossibleDate).TotalDays);
            // initialize calendar cells
            for(int i = 0; i < _totalCells; i++)
            {
                _calendarCellAttendeeCounts.Add(GetUsersAvailableAtIndex(i).Count());
            }
        }

        await InvokeAsync(StateHasChanged);
    }

    private void ResetCalendar()
    {
        _calendarCells.ForEach(x => x.CurrentState = UI.CalendarCell.State.Unavailable);
    }

    private List<User> GetUsersAvailableAtIndex(int index)
    {
        List<User> users = new();
        DateTime dateTime = GetDateTimeFromIndex(index);
        return context!.Users
            .Where(u => u.Attendance
                .Any(a => a.EventId == event_!.Id && a.Availability.Contains(dateTime)))
            .ToList();
    }

    private DateTime GetDateTimeFromIndex(int index)
    {
        DateTime dateTime = event_!.FirstPossibleDate;
        return dateTime.AddDays(index / 48).AddMinutes((index % 48) * 15);
    }

    private async void SubmitAvailability()
    {
        if (context != null && user_ != null)
        {
            List<DateTime> times = new();
            // Add all available 15 minute time slots to db
            for (int i = 0; i < _calendarCells.Count; i++)
            {
                var ts = _calendarCells[i];
                if (ts.CurrentState != UI.CalendarCell.State.Available) continue;

                // Create DateTime object for db, timestamp relative to event first possible date
                times.Add(GetDateTimeFromIndex(i));
            }

            // Create entry
            var newEntry = new Db.Attendance
            {
                UserId=user_.Id,
                EventId=event_!.Id,
                Availability=times
            };

            Attendance? entryToUpdate = null;
            if (context.Attendance.Count() > 0)
            {
                entryToUpdate = context.Attendance
                    .Where(a => a.UserId == user_.Id)
                    .Where(a => a.EventId == event_.Id)
                    .First();
            }

            Console.WriteLine(entryToUpdate == null);
            // Insert into db, either add or update if already exists
            if (entryToUpdate == null)
            {
                await context.AddAsync(newEntry);
            }
            else
            {
                context.Entry(entryToUpdate).CurrentValues.SetValues(newEntry);
            }
            await context.SaveChangesAsync();

        }
    }

    private async void DeleteUserAvailability()
    {
        context?.Attendance.RemoveRange(context.Attendance
            .Where(a => a.UserId == user_!.Id)
            .Where(a => a.EventId == event_!.Id)
            );
    
        await context?.SaveChangesAsync();
    }

    public void Dispose() => context?.Dispose();
}